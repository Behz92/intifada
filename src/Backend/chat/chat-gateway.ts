import { Inject } from "@nestjs/common";
import {
  WebSocketGateway,
  WebSocketServer,
  SubscribeMessage,
  OnGatewayConnection,
  OnGatewayDisconnect,
  ConnectedSocket,
  MessageBody,
} from "@nestjs/websockets";
import { Server, Socket } from "socket.io";
import { ChatService } from "./chat.service";
import { UsersService } from "src/Backend/users/users.service";
import { CoursesService } from "src/Backend/courses/courses.service";
import { GroupDocument } from "src/schemas/group.schema";
import { Instructor } from "src/schemas/instructor.schema";
import { User } from "src/schemas/user.schema";
import { InstructorService } from "../instructor/instructor.service";

@WebSocketGateway(3002, { cors: { origin: "*" } })
export class ChatGateway implements OnGatewayConnection, OnGatewayDisconnect {
  constructor(
    @Inject(ChatService) private readonly chatService: ChatService,
    @Inject(UsersService) private readonly userService: UsersService,
    @Inject(CoursesService) private readonly courseService: CoursesService,
    @Inject(InstructorService) private readonly instructorService: CoursesService
  ) {}

  @WebSocketServer() server: Server;

  private rooms: { [courseId: string]: string[] } = {};

  handleConnection(client: Socket) {
    console.log(`Client connected: ${client.id}`);
  }

  handleDisconnect(client: Socket) {
    console.log(`Client disconnected: ${client.id}`);
    Object.keys(this.rooms).forEach((courseId) => {
      this.rooms[courseId] = this.rooms[courseId].filter((id) => id !== client.id);
      this.server.to(courseId).emit("systemMessage", `User ${client.id} has left the chat.`);
    });
  }

// @SubscribeMessage('joinPrivateChat')
// async handleJoinPrivateChat(@MessageBody() data: any, @ConnectedSocket() client: Socket) {
//   try {
//     const { roomId, userId } = data;

//     if (!roomId || !userId) {
//       throw new Error('Missing roomId or userId.');
//     }

//     // User joins the room
//     client.join(roomId);
//     console.log(`User ${userId} joined private chat room: ${roomId}`);

//     // Retrieve and send chat history
//     const messages = await this.chatService.getPrivateMessages(roomId);
//     client.emit('chatHistory', messages);
//   } catch (error) {
//     console.error('Error in handleJoinPrivateChat:', error.message);
//     client.emit('error', { message: error.message });
//   }
// }

// @SubscribeMessage('sendPrivateMessage')
// async handleSendPrivateMessage(@MessageBody() data: any, @ConnectedSocket() client: Socket) {
//   try {
//     const { roomId, senderId, senderName, content } = data;

//     if (!roomId || !senderId || !content || !senderName) {
//       throw new Error('Missing roomId, senderId, senderName, or content.');
//     }

//     // Save the message to the database
//     const message = await this.chatService.savePrivateMessage(roomId, senderId, senderName, content);

//     // Broadcast the message to the room
//     this.server.to(roomId).emit('privateChatMessage', message);
//     console.log(`Message sent in room ${roomId} by ${senderName}: ${content}`);
//   } catch (error) {
//     console.error('Error in handleSendPrivateMessage:', error.message);
//     client.emit('error', { message: error.message });
//   }
// }

@SubscribeMessage('createGroup')
async handleCreateGroup(
  @MessageBody() data: any,
  @ConnectedSocket() client: Socket,
) {
  try {
    if (typeof data === "string") {
      data = JSON.parse(data);
    }

    const name = data?.name?.trim();
    const groupId = data?.groupId?.trim();
    const members = data?.members || [];
    const courseId = data?.courseId?.trim();

    // Validate input data
    if (!name || !groupId || !courseId) {
      throw new Error('Missing groupName, groupid or courseid');
    }

    // Call the service to create the group
    const group = await this.chatService.createGroup({
      name,
      groupId,
      members,
      courseId,
    });

    // Notify the creator about the successful group creation
    client.emit('groupCreated', { group });

    // Notify all group members (if connected) about the new group
    members.forEach((memberId: string) => {
      client.to(memberId).emit('newGroup', { group });
    });

    console.log(`Group created: ${name}, ID: ${groupId}`);
  } catch (error) {
    console.error('Error creating group:', error.message);
    client.emit('error', { message: error.message });
  }
}

@SubscribeMessage('joinGroup')
async handleJoinGroup(
  @MessageBody() data: any,
  @ConnectedSocket() client: Socket,
) {
  try {
    // Parse incoming data if it's a string
    if (typeof data === 'string') {
      data = JSON.parse(data);
    }

    // Extract necessary data from the payload
    const groupId = data?.groupId?.trim(); // The group ID generated by MongoDB
    const userId = data?.userId?.trim(); // The user joining the group

    // Validate input data
    if (!groupId || !userId) {
      throw new Error('Missing groupId or userId.');
    }

    // Find the group based on groupId
    const group = await this.chatService.findGroupById(groupId);
    if (!group) {
      throw new Error('Group not found.');
    }

    // Find the user or instructor
    const participant = await this.chatService.findParticipantById(userId);
    if (!participant) {
      throw new Error('Participant not found.');
    }

    // Check if the participant is authorized to join the group (based on their roles)
    const isAuthorized =
      ('acceptedCourses' in participant && participant.acceptedCourses.includes(group.courseId)) || // Student
      ('Teach_Courses' in participant && participant.Teach_Courses.includes(group.courseId)); // Instructor

    if (!isAuthorized) {
      throw new Error('Not authorized to join this group.');
    }

    // Add the user to the group if they are not already a member
    if (!group.members.includes(userId)) {
      await this.chatService.addUserToGroup(groupId, userId);
    }

    // Join the group room using the groupId
    client.join(groupId);

    // Fetch and send the group chat history to the user
    const chatHistory = await this.chatService.getGroupMessages(groupId);
    client.emit('chatHistory', chatHistory);

    // Notify all members of the group about the new participant
    this.server.to(groupId).emit('systemMessage', `${participant.name} joined the group chat.`);

    console.log(`${participant.name} joined the group: ${groupId}`);
  } catch (error) {
    console.error('Error in handleJoinGroup:', error.message);
    client.emit('error', { message: error.message });
  }
}


@SubscribeMessage("sendMessage")
async handleSendMessage(@MessageBody() data: any, @ConnectedSocket() client: Socket) {
  try {
    if (typeof data === "string") {
      data = JSON.parse(data);
    }

    const groupId = data?.groupId?.trim(); // The group ID
    const userId = data?.userId?.trim();   // The user ID
    const message = data?.message?.trim();  // The message content

    // Validate input
    if (!groupId || !userId || !message) {
      throw new Error("Missing groupId, userId, or message.");
    }

    // Fetch user or instructor to validate authorization
    const user = await this.userService.findUserById(userId);
    const instructor = await this.instructorService.findInstructorById(userId);

    if (!(user || instructor)) {
      throw new Error("User or instructor not found.");
    }

    // Find the group by groupId
    const group = await this.chatService.findGroupById(groupId);
    if (!group) {
      throw new Error("Group not found.");
    }

    // Check if the user or instructor is authorized to send messages in the group
    const isAuthorized =
      (user && user.acceptedCourses.includes(group.courseId)) || // If the user is in the course linked to the group
      (instructor && instructor.Teach_Courses.includes(group.courseId)); // If the instructor is teaching the course linked to the group

    if (!isAuthorized) {
      throw new Error("User is not authorized to send messages in this group.");
    }

    // Save the message to the database
    await this.chatService.saveMessage(groupId, userId, user?.name || instructor?.name, message);
    console.log(`Message in group ${groupId} from ${userId}: ${message}`);

    // Emit the message to all members of the group
    this.server.to(groupId).emit("chatMessage", {
      user: user?.name || instructor?.name,
      message,
    });
  } catch (error) {
    console.error("Error in handleSendMessage:", error.message);
    client.emit("error", { message: error.message });
  }
}

}